## ğŸ“š í”„ë¡œì„¸ìŠ¤
- ë¬¸ì œ ë§í¬
  <br /> https://school.programmers.co.kr/learn/courses/30/lessons/42587
  
- í’€ì´ ë°©ë²•
  <br /> `ë¬¸ì œì˜ ë™ì‘ ìˆœì„œë¥¼ ë”°ë¥¼ë ¤ê³  í–ˆìŠµë‹ˆë‹¤`
  <br /> `ìš°ì„  ìˆœìœ„ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ resultë¡œ ì¶”ì í•˜ê³ `
  <br /> `ì •ë ¬ ë˜ì§€ ì•Šì€ ì›ë³¸ í”„ë¡œì„¸ìŠ¤ì™€ ìš°ì„ ìˆœìœ„ë¥¼ ë¹„êµí•´ì„œ ìœ„ì¹˜ë¥¼ íŒŒì•…í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤`
  
- í’€ì´ ì½”ë“œ
```java
import java.util.*;

class Solution {
    public int solution(int[] priorities, int location) {
        Queue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());
        Queue<Integer> originQueue = new LinkedList<>();

        for(int i : priorities) {
            queue.offer(i);
        }
        for(int i = 0; i < priorities.length; i++) {
            originQueue.offer(i);
        }

        int result = 1;
        
        while(!originQueue.isEmpty()) {
            int originIndex = originQueue.poll();
            int originValue = priorities[originIndex];
            int maxValue = queue.peek();
            
            if(originValue < maxValue) {
                originQueue.offer(originIndex);
            } else if (originValue == maxValue) {
                if(originIndex == location) {
                    return result;
                } else {
                    queue.remove();
                    result++;
                }
            }
        }
        return result;
    }
}
``` 
